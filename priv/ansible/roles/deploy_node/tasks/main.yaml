- name: setup_node
  environment:
    AWS_CONFIG_FILE: /home/admin/.aws/credentials
  block:
    - name: Populate service facts
      service_facts:

    - name: Find AWS file for {{ app_name }} in S3 {% if target_release_sha | length > 0 %} with sha {{ target_release_sha }} {% else %} latest {% endif %} and set it into variable
      ansible.builtin.script:
        cmd: >
          {% if target_release_sha | length > 0 %}
            find_aws_release_by_sha.sh {{ bucket_name }} {{ app_name }} {{ release_prefix }} {{ target_release_sha }}
          {% else %}
            latest_aws_release.sh {{ bucket_name }} {{ app_name }} {{ release_prefix }}
          {% endif %}
      register: aws_file_name

    - name: Create {{ app_name }} srv directory
      file:
        path: /srv/{{ app_name }}
        state: directory

    - name: Download {{ app_name }} from S3
      amazon.aws.aws_s3:
        bucket: "{{ bucket_name }}"
        mode: get
        object: "{{ aws_file_name.stdout_lines[0] }}"
        dest: /srv/{{ aws_file_name.stdout_lines[0] }}

    - name: Create /srv/{{ app_name }} directory
      file:
        path: /srv/{{ app_name }}
        state: directory
        owner: root
        group: root
        mode: 0755

    - name: Create /srv/unpack-directory directory
      file:
        path: /srv/unpack-directory
        state: directory
        owner: root
        group: root
        mode: 0755

    - name: Untar {{ aws_file_name.stdout_lines[0] }}
      unarchive:
        src: /srv/{{ aws_file_name.stdout_lines[0] }}
        dest: /srv/unpack-directory
        remote_src: true

    - name: Fetch current release from S3
      amazon.aws.aws_s3:
        bucket: "{{ bucket_name }}"
        mode: get
        object: "{{ release_state_prefix }}/{{ app_name }}/current_release.txt"
        dest: /tmp/current_release.txt
      register: current_release_fetch
      ignore_errors: true

    - name: Read current release content
      slurp:
        src: /tmp/current_release.txt
      register: current_release_content
      when: current_release_fetch is succeeded

    - name: Set current release fact
      set_fact:
        existing_release: "{{ (current_release_content.content | default('') | b64decode | trim) if current_release_fetch is succeeded else '' }}"

    - name: Set release changed fact
      set_fact:
        release_changed: "{{ existing_release != aws_file_name.stdout_lines[0] }}"

    - name: Fetch release history from S3
      amazon.aws.aws_s3:
        bucket: "{{ bucket_name }}"
        mode: get
        object: "{{ release_state_prefix }}/{{ app_name }}/release_history.txt"
        dest: /tmp/release_history.txt
      register: release_history_fetch
      ignore_errors: true
      when: release_changed | bool

    - name: Create empty release history if not exists
      copy:
        content: ""
        dest: /tmp/release_history.txt
      when: release_changed | bool and (release_history_fetch.failed | default(false))

    - name: Append current release to history
      shell: cat /tmp/current_release.txt >> /tmp/release_history.txt
      when: release_changed | bool and current_release_fetch is succeeded

    - name: Write new current release
      copy:
        content: "{{ aws_file_name.stdout_lines[0] }}\n"
        dest: /tmp/current_release.txt
      when: release_changed | bool

    - name: Upload current release to S3
      amazon.aws.aws_s3:
        bucket: "{{ bucket_name }}"
        mode: put
        object: "{{ release_state_prefix }}/{{ app_name }}/current_release.txt"
        src: /tmp/current_release.txt
      when: release_changed | bool

    - name: Upload release history to S3
      amazon.aws.aws_s3:
        bucket: "{{ bucket_name }}"
        mode: put
        object: "{{ release_state_prefix }}/{{ app_name }}/release_history.txt"
        src: /tmp/release_history.txt
      when: release_changed | bool

    - name: Skip release state update (same version)
      debug:
        msg: "Skipping release state update - already at {{ aws_file_name.stdout_lines[0] }}"
      when: not (release_changed | bool)

    - name: Add erlang_systemd.service file to /etc/systemd/system/{{ app_name }}.service
      template:
        src: erlang_systemd.service.j2
        dest: /etc/systemd/system/{{ app_name }}.service
        owner: root
        group: root
        mode: 0644
      # when: app_name == item
      # loop: "{{ erlang_systemd }}"

    - name: Add environment varaibles to systemd.service file
      lineinfile:
        path: /etc/systemd/system/{{ app_name }}.service
        insertafter: RestartSec=5
        line: "Environment=\"{{ item }}\""
      loop: "{{ system_env }}"

    - name: Enable {{ app_name }} service
      systemd:
        name: "{{ app_name }}"
        enabled: true

    - name: Stop {{ app_name }} service
      systemd:
        name: "{{ app_name }}"
        state: stopped
      when: ansible_facts.services[ app_name ] is not defined

    - name: Delete old /srv/{{ app_name }} directory
      file:
        path: /srv/{{ app_name }}
        state: absent

    - name: Copy /srv/unpack-directory directory to /srv/{{ app_name }}
      copy:
        src: /srv/unpack-directory/
        dest: /srv/{{ app_name }}/
        mode: 0755
        remote_src: true

    - name: Delete /srv/unpack-directory directory
      file:
        path: /srv/unpack-directory
        state: absent

    - name: Start {{ app_name }} service with {{ aws_file_name.stdout_lines[0] }}
      systemd:
        daemon_reload: true
        name: "{{ app_name }}"
        state: started

  become: true
