- name: save_ami
  block:
    - name: Get instance metadata
      uri:
        url: http://169.254.169.254/latest/meta-data/instance-id
        return_content: yes
      register: instance_id_result

    - name: Get AWS region
      uri:
        url: http://169.254.169.254/latest/meta-data/placement/region
        return_content: yes
      register: region_result

    - name: Set instance and region facts
      set_fact:
        instance_id: "{{ instance_id_result.content }}"
        aws_region: "{{ region_result.content }}"

    - name: Check if instance is a QA node
      command: >
        aws ec2 describe-tags
        --region {{ aws_region }}
        --filters "Name=resource-id,Values={{ instance_id }}" "Name=key,Values=QaNode"
        --query 'Tags[0].Value'
        --output text
      register: qa_node_check
      changed_when: false

    - name: Skip AMI creation for QA nodes
      debug:
        msg: "Skipping AMI creation - this is a QA node"
      when: qa_node_check.stdout == "true"

    - name: Create AMI from current instance
      command: >
        aws ec2 create-image
        --region {{ aws_region }}
        --instance-id {{ instance_id }}
        --name "{{ app_name }}-{{ env }}-{{ ansible_date_time.epoch }}"
        --description "Auto-generated AMI for {{ app_name }} in {{ env }} at {{ ansible_date_time.iso8601 }}"
        --tag-specifications 'ResourceType=image,Tags=[
          {Key=Name,Value={{ app_name }}-{{ env }}},
          {Key=App,Value={{ app_name }}},
          {Key=Environment,Value={{ env }}},
          {Key=CreatedAt,Value={{ ansible_date_time.iso8601 }}},
          {Key=ManagedBy,Value=DeployEx},
          {Key=Type,Value=AutoScaleReady}
        ]'
        --no-reboot
      register: ami_creation_result
      when: qa_node_check.stdout != "true"

    - name: Parse AMI ID from result
      set_fact:
        new_ami_id: "{{ (ami_creation_result.stdout | from_json).ImageId }}"
      when: qa_node_check.stdout != "true"

    - name: Store AMI ID in SSM Parameter Store
      command: >
        aws ssm put-parameter
        --region {{ aws_region }}
        --name "/deploy_ex/{{ env }}/{{ app_name }}/latest_ami"
        --value "{{ new_ami_id }}"
        --type String
        --overwrite
        --description "Latest AMI for {{ app_name }} in {{ env }}"
      when: qa_node_check.stdout != "true"

    - name: Wait for AMI to be available (async, non-blocking)
      command: >
        aws ec2 wait image-available
        --region {{ aws_region }}
        --image-ids {{ new_ami_id }}
      async: 1800
      poll: 0
      register: ami_wait_task
      when: qa_node_check.stdout != "true"

    - name: Log AMI creation success
      debug:
        msg: "Created AMI {{ new_ami_id }} for {{ app_name }}-{{ env }}. AMI will be available in ~5-10 minutes."
      when: qa_node_check.stdout != "true"

    - name: Cleanup old AMIs (keep last 3)
      shell: |
        aws ec2 describe-images \
          --region {{ aws_region }} \
          --owners self \
          --filters "Name=tag:App,Values={{ app_name }}" "Name=tag:Environment,Values={{ env }}" "Name=tag:ManagedBy,Values=DeployEx" \
          --query 'Images | sort_by(@, &CreationDate) | [:-3].[ImageId]' \
          --output text | while read ami_id; do
            if [ -n "$ami_id" ]; then
              echo "Deregistering old AMI: $ami_id"
              aws ec2 deregister-image --region {{ aws_region }} --image-id $ami_id || true
            fi
          done
      register: cleanup_result
      ignore_errors: yes
      when: qa_node_check.stdout != "true"

    - name: Log cleanup result
      debug:
        msg: "{{ cleanup_result.stdout_lines }}"
      when: qa_node_check.stdout != "true" and cleanup_result.stdout_lines | length > 0

  become: true
